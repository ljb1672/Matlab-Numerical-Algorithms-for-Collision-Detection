%% 求解两个三角形之间的最短距离
%% 使用二次规划方法，在CVX中实现
%% 清屏清内存
clc;
clear;
%% 距离矩阵
%  1  0 -1  0
%  0  1  0 -1
% -1  0  1  0
%  0 -1  0  1
P0 = [ 1 , 0 , -1 , 0 ;
       0 , 1 , 0 , -1 ; 
      -1 , 0 , 1 , 0 ; 
       0 , -1 , 0 , 1 ];
q0 = [ 0 , 0 , 0 , 0 ]';
r0 = 0;
%% 6 条直线组成的2个三角形
%  1  0  0  0
%  0  1  0  0
% -1 -2  0  0
%  0  0  0  1
%  0  0  1  1
%  0  0 -1 -2
A = [ 1 , 0 , 0 , 0 ;      % x1 >= 0         属于第一个三角形，蓝色
      0 , 1 , 0 , 0 ;      % x2 >= 0         属于第一个三角形，蓝色
     -1 ,-2 , 0 , 0 ;      % x1 + x2 <= 2    属于第一个三角形，蓝色
      0 , 0 , 0 , 1 ;      % x4 >=2             属于第二个三角形，绿色
      0 , 0 , 1 , 1 ;      % x3 + x4 >=3        属于第二个三角形，绿色
      0 , 0 , -1 ,-2 ];    % x3 + 2 * x4 <= 6   属于第二个三角形，绿色

b = [ 0 , 0 , -2 , 2 , 3 , -6 ]'; % 不等式右端值

n = 4;
%% cvx
fprintf( 1 , '计算 QP 的最优值...\n');

cvx_begin 
    cvx_precision best    % 使用最好的精度
    cvx_solver sedumi     % 使用sedumi求解器
    variable x( n )
    minimize ( quad_form( x , P0 ) + q0' * x + r0 ); % 目标函数
    subject to
    A * x >= b;                % 不等式约束
cvx_end
%显示结果
format long;                   % 设置显示高精度数据
display( sqrt( cvx_optval ));  % 显示求解结果
display( sqrt( quad_form( x , P0 ) + q0' * x + r0 )); % 显示最小值
display( x );                  % 显示目标值

%% 画三角形
x1 = [ 0.0   2.0   0.0  0.0 ];  %属于第一个三角形，蓝色，x 坐标
y1 = [ 0.0   0.0   1.0  0.0 ];  %属于第一个三角形，蓝色，y 坐标
x2 = [ 1.0 , 2.0 , 0.0  1.0 ];  %属于第二个三角形，绿色，x 坐标
y2 = [ 2.0 , 2.0 , 3.0  2.0 ];  %属于第二个三角形，绿色，y 坐标
h = plot( x1 , y1 , 'k' , 'linewidth' , 2 );   % 画第一个三角形
set( h , 'Color' , 'Blue' );                   % 设置为蓝色
hold on;
h = plot( x2 , y2 , 'k' , 'linewidth' , 2 );   % 画第二个三角形
set( h , 'Color' , 'Green' );                  % 设置为绿色
hold on;
h = line([ x( 1 ) , x( 3 )],[ x( 2 ) , x( 4 )]);  % 画距离线段
set( h , 'Color' , 'Red' );                       % 设置为红色
grid on;
axis equal;
axis([ -1 3 -1 4 ]);




